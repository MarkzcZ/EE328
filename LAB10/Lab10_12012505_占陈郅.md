# Lab10_12012505_占陈郅



### Purpose of this lab

> 1. Test and understand the process of u-law  quantization 
> 2. Compare uniform and u-law quantizers on  their SNRs 
> 3. Test and understand the process of adaptive  quantization



### Lab results and analysis

#### Problem1

<img src="C:\Users\M__zzZ\AppData\Roaming\Typora\typora-user-images\image-20230425083011890.png" alt="image-20230425083011890" style="zoom:67%;" />

(a)

![1](C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\1.png)

​	U-law compression acts on a raw signal that is a straight line. When mu is small, the deformation of the straight line is not significant. As mu becomes larger, the first half of the straight line becomes lower and the second half becomes higher, and overall it becomes steeper. It can be concluded that mulaw will amplify the signal as it is large and reduce it as it is small.

Code

```matlab
x = -1:0.001:1;

u = 1;
y = mulaw(x,u);
subplot(321)
plot(y)
title('mu = 1')

...
```



(b)

| ![2](C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\2.png) | ![3](C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\3.png) |
| -------------------------------------------------------- | -------------------------------------------------------- |

Code

```matlab
[x,fs] = audioread("s5.wav");
u = 255;
y = mulaw(x(1300:18800),u);
figure
plot(y)
title('output of μ-law(1300 to 18800 samples)')
h = histogram(y);
title('histogram of the output')
```



(c)

<img src="C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\4.png" alt="4" style="zoom:75%;" />

*Mulawinv* correctly restored the original signal.

Code

```matlab
x = -1:0.001:1;
u = 255;
v = mulawinv(mulaw(x,u),u)
subplot(211)
plot(x)
title('original signal x')
subplot(212)
plot(v)
title('inverse signal v')
```



(d)

Uniform quantizers with 4 bits

| ![5](C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\5.png) | ![6](C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\6.png) |
| -------------------------------------------------------- | -------------------------------------------------------- |

Uniform quantizers with 8 bits

| ![7](C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\7.png) | ![8](C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\8.png) |
| -------------------------------------------------------- | -------------------------------------------------------- |

Uniform quantizers with 10 bits

| ![5](C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\9.png) | ![6](C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\10.png) |
| -------------------------------------------------------- | --------------------------------------------------------- |

​	The larger the number of bits, the more concentrated the histogram of the quantification error, and the smaller the amplitude value of the power plot.

Code

```matlab
[x,fs] = audioread("s5.wav");
u = 255;
x1 = x(1:8000)
yh = fxquant(mulaw(x1,u),4,'round','sat');
e = mulawinv(yh,u) - x1;
h = histogram(e)
title('histogram of quantization errors')
[pows, freq] = analyse_power_spectrum(e, fs)
plot(pows)
title('power spectrums of quantization errors')

function [pows, freq] = analyse_power_spectrum(X, Fs)
  % calculate the FFT of the signal X, transform to power, and
  % generate frequency range according to the sampling rate Fs

  N = length(X);

  % take FFT and shift it for symmetry
  amp = fftshift(fft(X));

  % make frequency range
  fN = N - mod(N, 2);
  k = -fN/2 : fN/2 - 1;
  T = N / Fs;
  freq = k/T;

  % select the positive domain FFT and range
  one_idx = fN/2 + 2;
  amp = amp(one_idx:end);
  freq = freq(one_idx:end);

  % return power spectrum
  pows = abs(amp).^2;
end
```



#### Problem 2

<img src="C:\Users\M__zzZ\AppData\Roaming\Typora\typora-user-images\image-20230425083520109.png" alt="image-20230425083520109" style="zoom:67%;" />

(a)

```matlab
function [ s_n_r, e ] = snr( xh, x )
%SNR function for computing snr
% [s_n_r,e]=snr(xh,x)
% xh=quantized signal
% x=unquantized signal
% e=quantization error signal (optional)
% s_n_r=snr in dB
s_n_r = 10*log10(sum(x.^2)/sum((xh-x).^2));
e = x-xh;
end

>> signal = audioread('s5.wav');
signal_8 = fxquant(signal, 8, 'round', 'sat');
signal_9 = fxquant(signal, 9, 'round', 'sat');
snr8 = snr(signal_8, signal);
snr9 = snr(signal_9, signal);

>> snr8 = 37.8333
>> snr9 = 43.4176
>> snr9 - snr8 = 5.5843
```

The value roughly matches the expected amount 6 dB, as the bit number is increased by one.



(b)

<img src="C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\13.png" alt="13" style="zoom:75%;" />

<img src="C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\12.png" alt="12" style="zoom:75%;" />

<img src="C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\11.png" alt="11" style="zoom:75%;" />

Code

```matlab
clear;clc
mu = 500;
signal = audioread('s5.wav');
hold on;
for i = 10:-1:6
    SNRplot(signal, mu, i);
end
hold off;
xlabel('1/sigmax');ylabel('SNR in dB');title(sprintf('mu=%d',mu));
legend('10bit','10bit','9bit','9bit','8bit','8bit','7bit','7bit','6bit','6bit');


function [ signal ] = SNRplot( signal, mu, bit)
%SNRPLOR plot a single line
% signal: input signal array
% mu: factor for mu-law
% bit: quantization bit number

% x-axis: 1/sigma, 13 samples
% y-axis: SNR, 13 samples
factor = 1*2.^(0:-1:-12)';
signal = factor*signal';
signal = signal';
SNR_mu = zeros(1,13);
SNR_uni = zeros(1,13);
standard = std(signal);
% mulaw and quantization
for i = 1:13
    signal_f = signal(:,i);
    signal_compress = mulaw(signal_f, mu);
    signal_q = fxquant(signal_compress, bit, 'round', 'sat');
    signal_expand = mulawinv(signal_q, mu);
    SNR_mu(i) = snr(signal_expand, signal_f);
    SNR_uni(i) = snr(fxquant(signal_f,bit,'round','sat'),signal_f);
end
semilogx(1./standard, SNR_mu);
semilogx(1./standard, SNR_uni,'--');
grid;
```

​	To compute the values, I write a function called SNRplot, which plots two lines in a single run:  the mu-law curve and the corresponding uniform curve.

​	As mu increases, the curves of mu-law quantizer could maintain as a flat line for a greater  range. To reach the effect of 6bit mu-law quantizer, a uniform quantizer must have at least  9bit. The enhancement of mu-law quantizer is significant. However, we can observe that at the beginning of the curves, SNR is slightly smaller when  mu is bigger. I think this is because when variance is small, the quantization error might be  amplified as mu gets bigger.



#### Problem 3

<img src="C:\Users\M__zzZ\AppData\Roaming\Typora\typora-user-images\image-20230425090600138.png" alt="image-20230425090600138" style="zoom:67%;" />

1.

<img src="C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\14.png" alt="14" style="zoom:75%;" />

​	The resulting plot shows two subplots, one for each filter coefficient, with the speech samples in blue and the standard deviation samples in red. The legend indicates which line corresponds to the speech samples and which corresponds to the standard deviation samples.

​	When a = 0.99, the amplitude of standard deviation becomes larger, and the amplitude of speech samples does not change.

Code

```matlab
% Load speech file
[x, Fs] = audioread('s5.wav');

% Define filter coefficients
a1 = 0.9;
a2 = 0.99;

% Apply IIR filter to speech signal
y1 = filter(1, [1, -a1], x);
y2 = filter(1, [1, -a2], x);

% Calculate standard deviation of filtered signal
o1 = std(y1);
o2 = std(y2);

% Define sample range
n = 2700:6700;

% Plot speech samples and superimposed standard deviation samples
figure;
subplot(2,1,1);
plot(n, x(n));
hold on;
plot(n, y1(n) + o1, 'r');
plot(n, y1(n) - o1, 'r');
title('Speech Samples and Standard Deviation (a = 0.9)');
xlabel('Sample Number');
ylabel('Amplitude');
legend('Speech Samples', 'Standard Deviation');

subplot(2,1,2);
plot(n, x(n));
hold on;
plot(n, y2(n) + o2, 'r');
plot(n, y2(n) - o2, 'r');
title('Speech Samples and Standard Deviation (a = 0.99)');
xlabel('Sample Number');
ylabel('Amplitude');
legend('Speech Samples', 'Standard Deviation');
```



2.(a)

<img src="C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\15.png" alt="15" style="zoom:80%;" />

```matlab
% Load speech file
[s, Fs] = audioread('s5.wav');

% Calculate standard deviation of speech signal
o = std(s);

% Apply IIR filter with a = 0.9
a = 0.9;
b = 1 - a;
y1 = filter(b, [1, -a], s);

% Apply IIR filter with a = 0.99
a = 0.99;
b = 1 - a;
y2 = filter(b, [1, -a], s);

% Plot original signal and filtered signals
figure;
subplot(2,1,1);
plot(s);
title('Original Speech Signal');
xlabel('Sample Number');
ylabel('Amplitude');
subplot(2,1,2);
plot(y1/o);
hold on;
plot(y2/o);
title('Equalized Speech Signal');
xlabel('Sample Number');
ylabel('Amplitude');
legend('a = 0.9', 'a = 0.99');
```

   (b)

<img src="C:\Users\M__zzZ\Documents\MATLAB\EE328\LAB10\16.png" alt="16" style="zoom:80%;" />

```matlab
% Apply FIR filter with rectangular window of duration M = 10
M = 10;
h = ones(M,1)/M;
y3 = conv(s,h,'same');

% Apply FIR filter with rectangular window of duration M = 100
M = 100;
h = ones(M,1)/M;
y4 = conv(s,h,'same');

% Plot original signal and filtered signals
figure;
subplot(2,1,1);
plot(s);
title('Original Speech Signal');
xlabel('Sample Number');
ylabel('Amplitude');
subplot(2,1,2);
plot(y3/o);
hold on;
plot(y4/o);
title('Equalized Speech Signal');
xlabel('Sample Number');
ylabel('Amplitude');
legend('M = 10', 'M = 100');
```

​	Based on the plots, we can see that the IIR filter with a = 0.9 and the FIR filter with rectangular window of duration M = 10 produce similar results, with both filters reducing the high-frequency noise in the speech signal. The IIR filter with a = 0.99 and the FIR filter with rectangular window of duration M = 100 also produce similar results, with both filters reducing the low-frequency noise in the speech signal.

​	Overall, the filters appear to be effective in reducing noise in the speech signal, with the IIR filter with a = 0.9 and the FIR filter with rectangular window of duration M = 10 producing the best results for high-frequency noise, and the IIR filter with a = 0.99 and the FIR filter with rectangular window of duration M = 100 producing the best results for low-frequency noise.